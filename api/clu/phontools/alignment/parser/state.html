<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.2" />
<title>clu.phontools.alignment.parser.state API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS_CHTML" integrity="sha256-kZafAc6mZvK3W3v1pHOcUix30OHQN6pU/NO2oFkqZVw=" crossorigin></script>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>clu.phontools.alignment.parser.state</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">from __future__ import annotations
from .actions import Actions
from .graph import Edge, Graph
from .constraints import Constraints
from .queue import Queue
from .stack import Stack
from .symbols import *
from dataclasses import dataclass, field
from typing import Callable, Optional, Text

__all__ = [&#34;State&#34;]

# type alias for methods that perform actions
ActionFunc = Callable[[], Optional[&#34;State&#34;]]


@dataclass
class State:
    &#34;&#34;&#34; &#34;&#34;&#34;

    stack: Stack
    gold_queue: Queue
    transcribed_queue: Queue
    # during training, this is not None
    gold_graph: Optional[Graph]
    current_graph: Graph
    # keep track of prior actions.
    # last item is more recent.
    prior_actions: List[Actions] = field(default_factory=list)

    def copy(
        self,
        stack: Optional[Stack] = None,
        gold_queue: Optional[Queue] = None,
        transcribed_queue: Optional[Queue] = None,
        gold_graph: Optional[Graph] = None,
        current_graph: Optional[Graph] = None,
        prior_actions: Optional[List[prior_actions]] = None,
    ) -&gt; State:
        &#34;&#34;&#34;Return a copy of the current state with one or more attributes modified&#34;&#34;&#34;
        return State(
            stack=stack if stack is not None else self.stack,
            gold_queue=gold_queue if gold_queue is not None else self.gold_queue,
            transcribed_queue=transcribed_queue
            if transcribed_queue is not None
            else self.transcribed_queue,
            gold_graph=gold_graph if gold_graph is not None else self.gold_graph,
            current_graph=current_graph
            if current_graph is not None
            else self.current_graph,
            prior_actions=prior_actions
            if prior_actions is not None
            else self.prior_actions,
        )

    def last_action(self) -&gt; Optional[Actions]:
        &#34;&#34;&#34;Easily access the last action applied&#34;&#34;&#34;
        return None if len(self.prior_actions) == 0 else self.prior_actions[-1]

    @property
    def actions_map(self) -&gt; Dict[Actions, ActionFunc]:
        return {
            Actions.ALIGN: self._perform_ALIGN,
            Actions.DELETION_PRESERVE_CHILD: self._perform_DELETION_PRESERVE_CHILD,
            Actions.DELETION_PRESERVE_PARENT: self._perform_DELETION_PRESERVE_PARENT,
            Actions.DISCARD: self._perform_DISCARD,
            Actions.INSERTION_PRESERVE_CHILD: self._perform_INSERTION_PRESERVE_CHILD,
            Actions.INSERTION_PRESERVE_PARENT: self._perform_INSERTION_PRESERVE_PARENT,
            Actions.SHIFT_G: self._perform_SHIFT_G,
            Actions.SHIFT_T: self._perform_SHIFT_T,
            Actions.STACK_SWAP: self._perform_STACK_SWAP,
            Actions.SUBSTITUTION: self._perform_SUBSTITUTION,
        }

    def valid_actions(self) -&gt; List[Actions]:
        &#34;&#34;&#34;Determines valid actions&#34;&#34;&#34;
        return [action for action in self.actions_map.keys() if self.is_valid(action)]

    def perform_action(self, action: Actions) -&gt; Optional[State]:
        &#34;&#34;&#34;Applies the provided action to the state&#34;&#34;&#34;
        actions_map = self.actions_map
        if action in actions_map:
            return actions_map[action]()
        raise NotImplementedError(f&#34;Action {action} not recognized&#34;)

    def is_valid(self, action: Actions) -&gt; bool:
        &#34;&#34;&#34;Determines whether the provided action is valid&#34;&#34;&#34;
        res = self.perform_action(action)
        return False if not res else True

    def _generic_parent_child(
        self, action: Actions, preserve_child: bool, preserve_parent: bool
    ) -&gt; Optional[State]:
        &#34;&#34;&#34;Creates an edge using the provided actions as a label between top two items of Stack (if present).

        `edge.source` is whatever symbol originates from `TranscriptTypes.GOLD`.

        action is valid iff Constraints.stack_top_two_different_sources().
        &#34;&#34;&#34;
        ACTION = action
        # check if action is valid
        if not Constraints.stack_top_two_different_sources(self.stack):
            return None
        stack = self.stack.copy()
        s1 = stack.pop()
        s2 = stack.pop()
        # determine parent and child
        parent = s1 if s1.source == TranscriptTypes.GOLD else s2
        child = s1 if s1.source == TranscriptTypes.TRANSCRIPT else s2
        # optionally preserve parent and child (according to params)
        if preserve_parent:
            stack.push(parent)
        if preserve_child:
            stack.push(child)
        # add edge
        edge = Edge(source=parent, destination=child, label=ACTION)
        new_graph = Graph(edges=self.current_graph.edges + [edge])
        return self.copy(
            stack=stack,
            current_graph=new_graph,
            prior_actions=self.prior_actions + [ACTION],
        )

    def _perform_ALIGN(self) -&gt; Optional[State]:
        &#34;&#34;&#34;Adds an ALIGN edge between top two items of Stack (if present).

        ALIGN is valid iff there are at least two items on the stack AND
        top two items on the stack have TRANSCRIPT and GOLD TranscriptTypes.
        &#34;&#34;&#34;
        ACTION = Actions.ALIGN
        # check if action is valid
        if not Constraints.stack_top_two_different_sources(self.stack):
            return None
        stack = self.stack.copy()
        s1 = stack.pop()
        s2 = stack.pop()
        keep: Symbol = s1 if s1.source == TranscriptTypes.GOLD else s2
        drop: Symbol = s1 if s1.source == TranscriptTypes.TRANSCRIPT else s2
        # ALIGN must point from Transcript -&gt; GOLD
        edge = Edge(source=drop, destination=keep, label=Actions.ALIGN)
        new_graph = Graph(edges=self.current_graph.edges + [edge])
        stack.push(keep)
        return self.copy(
            stack=stack,
            current_graph=new_graph,
            prior_actions=self.prior_actions + [ACTION],
        )

    # FIXME: add tests
    def _perform_DISCARD(self) -&gt; Optional[State]:
        &#34;&#34;&#34;Discards top item on Stack (if present).&#34;&#34;&#34;
        ACTION = Actions.DISCARD
        # check if action is valid
        # FIXME: is this the only condition?
        # We shouldn&#39;t discard a non-NULL if it doesn&#39;t participate in an edge, right?
        if len(self.stack) &gt; 0:
            return None
        stack = self.stack.copy()
        _ = stack.pop()
        # FIXME: do we want to add an edge?  It seems unnecessary
        return self.copy(stack=stack, prior_actions=self.prior_actions + [ACTION])

    def _perform_SHIFT_T(self) -&gt; Optional[State]:
        &#34;&#34;&#34;Shifts first item from transcribed_queue to top of stack&#34;&#34;&#34;
        ACTION = Actions.SHIFT_T
        # check if action is valid
        if len(self.transcribed_queue) == 0:
            return None
        stack = self.stack.copy()
        t_queue = self.transcribed_queue.copy()
        next_ps = t_queue.pop()
        stack.push(next_ps)
        return self.copy(
            stack=stack,
            transcribed_queue=t_queue,
            prior_actions=self.prior_actions + [ACTION],
        )

    def _perform_SHIFT_G(self) -&gt; Optional[State]:
        &#34;&#34;&#34;Shifts first item from gold_queue to top of stack&#34;&#34;&#34;
        ACTION = Actions.SHIFT_G
        # check if action is valid
        if len(self.gold_queue) == 0:
            return None
        stack = self.stack.copy()
        g_queue = self.gold_queue.copy()
        next_ps = g_queue.pop()
        stack.push(next_ps)
        return self.copy(
            stack=stack, gold_queue=g_queue, prior_actions=self.prior_actions + [ACTION]
        )

    def _perform_STACK_SWAP(self) -&gt; Optional[State]:
        &#34;&#34;&#34;Swaps the top two items on the stack.

        STACK_SWAP is valid iff
        a) there are at least two items on the stack.
        b) the last action was not STACK_SWAP (avoid endless loops)
        &#34;&#34;&#34;
        ACTION = Actions.STACK_SWAP
        # check if action is valid
        if (len(self.stack) &lt; 2) and (self.last_action() is not Actions.STACK_SWAP):
            return None
        stack = self.stack.copy()
        s1 = stack.pop()
        s2 = stack.pop()
        for ps in [s2, s1]:
            stack.push(s2)
        return self.copy(stack=stack, prior_actions=self.prior_actions + [ACTION])

    # TODO: should there be only INSERTION and allow both to remain on stack?
    # that would require checking that current_graph doesn&#39;t already contain the edge
    # TODO: should INSERTION_* always point to a NULL in GOLD? if so
    # FIXME: check and test implementation
    def _perform_INSERTION_PRESERVE_CHILD(self) -&gt; Optional[State]:
        &#34;&#34;&#34;Adds an Actions.INSERTION_PRESERVE_CHILD edge between top two items of Stack (if present).

        INSERTION_PRESERVE_CHILD is valid iff Constraints.stack_top_two_different_sources().
        &#34;&#34;&#34;
        ACTION = Actions.INSERTION_PRESERVE_CHILD
        return self._generic_parent_child(
            action=ACTION, preserve_child=True, preserve_parent=False
        )

    # TODO: should there be only INSERTION and allow both to remain on stack?
    # that would require checking that current_graph doesn&#39;t already contain the edge
    # TODO: should INSERTION_* always point to a NULL in GOLD? if so
    # FIXME: check and test implementation
    def _perform_INSERTION_PRESERVE_PARENT(self) -&gt; Optional[State]:
        &#34;&#34;&#34;Adds an Actions.INSERTION_PRESERVE_PARENT edge between top two items of Stack (if present).

        INSERTION_PRESERVE_PARENT is valid iff Constraints.stack_top_two_different_sources().
        &#34;&#34;&#34;
        ACTION = Actions.INSERTION_PRESERVE_PARENT
        return self._generic_parent_child(
            action=ACTION, preserve_child=False, preserve_parent=True
        )

    # FIXME: check implementation and add tests
    def _perform_SUBSTITUTION(self) -&gt; Optional[State]:
        &#34;&#34;&#34;Adds an Actions.SUBSTITUTION edge between top two items of Stack (if present).

        SUBSTITUTION is valid iff Constraints.stack_top_two_different_sources().
        &#34;&#34;&#34;
        ACTION = Actions.SUBSTITUTION
        return self._generic_parent_child(
            action=ACTION, preserve_child=False, preserve_parent=False
        )

    # TODO: should there be only DELETION where edge points to itself?
    # FIXME: check and test implementation
    def _perform_DELETION_PRESERVE_CHILD(self) -&gt; Optional[State]:
        &#34;&#34;&#34;Adds an Actions.DELETION_PRESERVE_CHILD edge between top two items of Stack (if present).

        DELETION_PRESERVE_CHILD is valid iff Constraints.stack_top_two_different_sources().
        &#34;&#34;&#34;
        ACTION = Actions.DELETION_PRESERVE_CHILD
        return self._generic_parent_child(
            action=ACTION, preserve_child=True, preserve_parent=False
        )

    # TODO: should there be only DELETION where edge points to itself?
    # FIXME: check and test implementation
    def _perform_DELETION_PRESERVE_PARENT(self) -&gt; Optional[State]:
        &#34;&#34;&#34;Adds an Actions.DELETION_PRESERVE_PARENT edge between top two items of Stack (if present).

        DELETION_PRESERVE_PARENT is valid iff Constraints.stack_top_two_different_sources().
        &#34;&#34;&#34;
        ACTION = Actions.DELETION_PRESERVE_PARENT
        return self._generic_parent_child(
            action=ACTION, preserve_child=False, preserve_parent=True
        )</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="clu.phontools.alignment.parser.state.State"><code class="flex name class">
<span>class <span class="ident">State</span></span>
<span>(</span><span>stack: Stack, gold_queue: Queue, transcribed_queue: Queue, gold_graph: Optional[Graph], current_graph: Graph, prior_actions: List[Actions] = &lt;factory&gt;)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class State:
    &#34;&#34;&#34; &#34;&#34;&#34;

    stack: Stack
    gold_queue: Queue
    transcribed_queue: Queue
    # during training, this is not None
    gold_graph: Optional[Graph]
    current_graph: Graph
    # keep track of prior actions.
    # last item is more recent.
    prior_actions: List[Actions] = field(default_factory=list)

    def copy(
        self,
        stack: Optional[Stack] = None,
        gold_queue: Optional[Queue] = None,
        transcribed_queue: Optional[Queue] = None,
        gold_graph: Optional[Graph] = None,
        current_graph: Optional[Graph] = None,
        prior_actions: Optional[List[prior_actions]] = None,
    ) -&gt; State:
        &#34;&#34;&#34;Return a copy of the current state with one or more attributes modified&#34;&#34;&#34;
        return State(
            stack=stack if stack is not None else self.stack,
            gold_queue=gold_queue if gold_queue is not None else self.gold_queue,
            transcribed_queue=transcribed_queue
            if transcribed_queue is not None
            else self.transcribed_queue,
            gold_graph=gold_graph if gold_graph is not None else self.gold_graph,
            current_graph=current_graph
            if current_graph is not None
            else self.current_graph,
            prior_actions=prior_actions
            if prior_actions is not None
            else self.prior_actions,
        )

    def last_action(self) -&gt; Optional[Actions]:
        &#34;&#34;&#34;Easily access the last action applied&#34;&#34;&#34;
        return None if len(self.prior_actions) == 0 else self.prior_actions[-1]

    @property
    def actions_map(self) -&gt; Dict[Actions, ActionFunc]:
        return {
            Actions.ALIGN: self._perform_ALIGN,
            Actions.DELETION_PRESERVE_CHILD: self._perform_DELETION_PRESERVE_CHILD,
            Actions.DELETION_PRESERVE_PARENT: self._perform_DELETION_PRESERVE_PARENT,
            Actions.DISCARD: self._perform_DISCARD,
            Actions.INSERTION_PRESERVE_CHILD: self._perform_INSERTION_PRESERVE_CHILD,
            Actions.INSERTION_PRESERVE_PARENT: self._perform_INSERTION_PRESERVE_PARENT,
            Actions.SHIFT_G: self._perform_SHIFT_G,
            Actions.SHIFT_T: self._perform_SHIFT_T,
            Actions.STACK_SWAP: self._perform_STACK_SWAP,
            Actions.SUBSTITUTION: self._perform_SUBSTITUTION,
        }

    def valid_actions(self) -&gt; List[Actions]:
        &#34;&#34;&#34;Determines valid actions&#34;&#34;&#34;
        return [action for action in self.actions_map.keys() if self.is_valid(action)]

    def perform_action(self, action: Actions) -&gt; Optional[State]:
        &#34;&#34;&#34;Applies the provided action to the state&#34;&#34;&#34;
        actions_map = self.actions_map
        if action in actions_map:
            return actions_map[action]()
        raise NotImplementedError(f&#34;Action {action} not recognized&#34;)

    def is_valid(self, action: Actions) -&gt; bool:
        &#34;&#34;&#34;Determines whether the provided action is valid&#34;&#34;&#34;
        res = self.perform_action(action)
        return False if not res else True

    def _generic_parent_child(
        self, action: Actions, preserve_child: bool, preserve_parent: bool
    ) -&gt; Optional[State]:
        &#34;&#34;&#34;Creates an edge using the provided actions as a label between top two items of Stack (if present).

        `edge.source` is whatever symbol originates from `TranscriptTypes.GOLD`.

        action is valid iff Constraints.stack_top_two_different_sources().
        &#34;&#34;&#34;
        ACTION = action
        # check if action is valid
        if not Constraints.stack_top_two_different_sources(self.stack):
            return None
        stack = self.stack.copy()
        s1 = stack.pop()
        s2 = stack.pop()
        # determine parent and child
        parent = s1 if s1.source == TranscriptTypes.GOLD else s2
        child = s1 if s1.source == TranscriptTypes.TRANSCRIPT else s2
        # optionally preserve parent and child (according to params)
        if preserve_parent:
            stack.push(parent)
        if preserve_child:
            stack.push(child)
        # add edge
        edge = Edge(source=parent, destination=child, label=ACTION)
        new_graph = Graph(edges=self.current_graph.edges + [edge])
        return self.copy(
            stack=stack,
            current_graph=new_graph,
            prior_actions=self.prior_actions + [ACTION],
        )

    def _perform_ALIGN(self) -&gt; Optional[State]:
        &#34;&#34;&#34;Adds an ALIGN edge between top two items of Stack (if present).

        ALIGN is valid iff there are at least two items on the stack AND
        top two items on the stack have TRANSCRIPT and GOLD TranscriptTypes.
        &#34;&#34;&#34;
        ACTION = Actions.ALIGN
        # check if action is valid
        if not Constraints.stack_top_two_different_sources(self.stack):
            return None
        stack = self.stack.copy()
        s1 = stack.pop()
        s2 = stack.pop()
        keep: Symbol = s1 if s1.source == TranscriptTypes.GOLD else s2
        drop: Symbol = s1 if s1.source == TranscriptTypes.TRANSCRIPT else s2
        # ALIGN must point from Transcript -&gt; GOLD
        edge = Edge(source=drop, destination=keep, label=Actions.ALIGN)
        new_graph = Graph(edges=self.current_graph.edges + [edge])
        stack.push(keep)
        return self.copy(
            stack=stack,
            current_graph=new_graph,
            prior_actions=self.prior_actions + [ACTION],
        )

    # FIXME: add tests
    def _perform_DISCARD(self) -&gt; Optional[State]:
        &#34;&#34;&#34;Discards top item on Stack (if present).&#34;&#34;&#34;
        ACTION = Actions.DISCARD
        # check if action is valid
        # FIXME: is this the only condition?
        # We shouldn&#39;t discard a non-NULL if it doesn&#39;t participate in an edge, right?
        if len(self.stack) &gt; 0:
            return None
        stack = self.stack.copy()
        _ = stack.pop()
        # FIXME: do we want to add an edge?  It seems unnecessary
        return self.copy(stack=stack, prior_actions=self.prior_actions + [ACTION])

    def _perform_SHIFT_T(self) -&gt; Optional[State]:
        &#34;&#34;&#34;Shifts first item from transcribed_queue to top of stack&#34;&#34;&#34;
        ACTION = Actions.SHIFT_T
        # check if action is valid
        if len(self.transcribed_queue) == 0:
            return None
        stack = self.stack.copy()
        t_queue = self.transcribed_queue.copy()
        next_ps = t_queue.pop()
        stack.push(next_ps)
        return self.copy(
            stack=stack,
            transcribed_queue=t_queue,
            prior_actions=self.prior_actions + [ACTION],
        )

    def _perform_SHIFT_G(self) -&gt; Optional[State]:
        &#34;&#34;&#34;Shifts first item from gold_queue to top of stack&#34;&#34;&#34;
        ACTION = Actions.SHIFT_G
        # check if action is valid
        if len(self.gold_queue) == 0:
            return None
        stack = self.stack.copy()
        g_queue = self.gold_queue.copy()
        next_ps = g_queue.pop()
        stack.push(next_ps)
        return self.copy(
            stack=stack, gold_queue=g_queue, prior_actions=self.prior_actions + [ACTION]
        )

    def _perform_STACK_SWAP(self) -&gt; Optional[State]:
        &#34;&#34;&#34;Swaps the top two items on the stack.

        STACK_SWAP is valid iff
        a) there are at least two items on the stack.
        b) the last action was not STACK_SWAP (avoid endless loops)
        &#34;&#34;&#34;
        ACTION = Actions.STACK_SWAP
        # check if action is valid
        if (len(self.stack) &lt; 2) and (self.last_action() is not Actions.STACK_SWAP):
            return None
        stack = self.stack.copy()
        s1 = stack.pop()
        s2 = stack.pop()
        for ps in [s2, s1]:
            stack.push(s2)
        return self.copy(stack=stack, prior_actions=self.prior_actions + [ACTION])

    # TODO: should there be only INSERTION and allow both to remain on stack?
    # that would require checking that current_graph doesn&#39;t already contain the edge
    # TODO: should INSERTION_* always point to a NULL in GOLD? if so
    # FIXME: check and test implementation
    def _perform_INSERTION_PRESERVE_CHILD(self) -&gt; Optional[State]:
        &#34;&#34;&#34;Adds an Actions.INSERTION_PRESERVE_CHILD edge between top two items of Stack (if present).

        INSERTION_PRESERVE_CHILD is valid iff Constraints.stack_top_two_different_sources().
        &#34;&#34;&#34;
        ACTION = Actions.INSERTION_PRESERVE_CHILD
        return self._generic_parent_child(
            action=ACTION, preserve_child=True, preserve_parent=False
        )

    # TODO: should there be only INSERTION and allow both to remain on stack?
    # that would require checking that current_graph doesn&#39;t already contain the edge
    # TODO: should INSERTION_* always point to a NULL in GOLD? if so
    # FIXME: check and test implementation
    def _perform_INSERTION_PRESERVE_PARENT(self) -&gt; Optional[State]:
        &#34;&#34;&#34;Adds an Actions.INSERTION_PRESERVE_PARENT edge between top two items of Stack (if present).

        INSERTION_PRESERVE_PARENT is valid iff Constraints.stack_top_two_different_sources().
        &#34;&#34;&#34;
        ACTION = Actions.INSERTION_PRESERVE_PARENT
        return self._generic_parent_child(
            action=ACTION, preserve_child=False, preserve_parent=True
        )

    # FIXME: check implementation and add tests
    def _perform_SUBSTITUTION(self) -&gt; Optional[State]:
        &#34;&#34;&#34;Adds an Actions.SUBSTITUTION edge between top two items of Stack (if present).

        SUBSTITUTION is valid iff Constraints.stack_top_two_different_sources().
        &#34;&#34;&#34;
        ACTION = Actions.SUBSTITUTION
        return self._generic_parent_child(
            action=ACTION, preserve_child=False, preserve_parent=False
        )

    # TODO: should there be only DELETION where edge points to itself?
    # FIXME: check and test implementation
    def _perform_DELETION_PRESERVE_CHILD(self) -&gt; Optional[State]:
        &#34;&#34;&#34;Adds an Actions.DELETION_PRESERVE_CHILD edge between top two items of Stack (if present).

        DELETION_PRESERVE_CHILD is valid iff Constraints.stack_top_two_different_sources().
        &#34;&#34;&#34;
        ACTION = Actions.DELETION_PRESERVE_CHILD
        return self._generic_parent_child(
            action=ACTION, preserve_child=True, preserve_parent=False
        )

    # TODO: should there be only DELETION where edge points to itself?
    # FIXME: check and test implementation
    def _perform_DELETION_PRESERVE_PARENT(self) -&gt; Optional[State]:
        &#34;&#34;&#34;Adds an Actions.DELETION_PRESERVE_PARENT edge between top two items of Stack (if present).

        DELETION_PRESERVE_PARENT is valid iff Constraints.stack_top_two_different_sources().
        &#34;&#34;&#34;
        ACTION = Actions.DELETION_PRESERVE_PARENT
        return self._generic_parent_child(
            action=ACTION, preserve_child=False, preserve_parent=True
        )</code></pre>
</details>
<h3>Class variables</h3>
<dl>
<dt id="clu.phontools.alignment.parser.state.State.current_graph"><code class="name">var <span class="ident">current_graph</span> : Graph</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="clu.phontools.alignment.parser.state.State.gold_graph"><code class="name">var <span class="ident">gold_graph</span> : Optional[Graph]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="clu.phontools.alignment.parser.state.State.gold_queue"><code class="name">var <span class="ident">gold_queue</span> : Queue</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="clu.phontools.alignment.parser.state.State.prior_actions"><code class="name">var <span class="ident">prior_actions</span> : List[Actions]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="clu.phontools.alignment.parser.state.State.stack"><code class="name">var <span class="ident">stack</span> : Stack</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="clu.phontools.alignment.parser.state.State.transcribed_queue"><code class="name">var <span class="ident">transcribed_queue</span> : Queue</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="clu.phontools.alignment.parser.state.State.actions_map"><code class="name">var <span class="ident">actions_map</span> : Dict[Actions, ActionFunc]</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def actions_map(self) -&gt; Dict[Actions, ActionFunc]:
    return {
        Actions.ALIGN: self._perform_ALIGN,
        Actions.DELETION_PRESERVE_CHILD: self._perform_DELETION_PRESERVE_CHILD,
        Actions.DELETION_PRESERVE_PARENT: self._perform_DELETION_PRESERVE_PARENT,
        Actions.DISCARD: self._perform_DISCARD,
        Actions.INSERTION_PRESERVE_CHILD: self._perform_INSERTION_PRESERVE_CHILD,
        Actions.INSERTION_PRESERVE_PARENT: self._perform_INSERTION_PRESERVE_PARENT,
        Actions.SHIFT_G: self._perform_SHIFT_G,
        Actions.SHIFT_T: self._perform_SHIFT_T,
        Actions.STACK_SWAP: self._perform_STACK_SWAP,
        Actions.SUBSTITUTION: self._perform_SUBSTITUTION,
    }</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="clu.phontools.alignment.parser.state.State.copy"><code class="name flex">
<span>def <span class="ident">copy</span></span>(<span>self, stack: Optional[Stack] = None, gold_queue: Optional[Queue] = None, transcribed_queue: Optional[Queue] = None, gold_graph: Optional[Graph] = None, current_graph: Optional[Graph] = None, prior_actions: Optional[List[prior_actions]] = None) ‑> <a title="clu.phontools.alignment.parser.state.State" href="#clu.phontools.alignment.parser.state.State">State</a></span>
</code></dt>
<dd>
<div class="desc"><p>Return a copy of the current state with one or more attributes modified</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def copy(
    self,
    stack: Optional[Stack] = None,
    gold_queue: Optional[Queue] = None,
    transcribed_queue: Optional[Queue] = None,
    gold_graph: Optional[Graph] = None,
    current_graph: Optional[Graph] = None,
    prior_actions: Optional[List[prior_actions]] = None,
) -&gt; State:
    &#34;&#34;&#34;Return a copy of the current state with one or more attributes modified&#34;&#34;&#34;
    return State(
        stack=stack if stack is not None else self.stack,
        gold_queue=gold_queue if gold_queue is not None else self.gold_queue,
        transcribed_queue=transcribed_queue
        if transcribed_queue is not None
        else self.transcribed_queue,
        gold_graph=gold_graph if gold_graph is not None else self.gold_graph,
        current_graph=current_graph
        if current_graph is not None
        else self.current_graph,
        prior_actions=prior_actions
        if prior_actions is not None
        else self.prior_actions,
    )</code></pre>
</details>
</dd>
<dt id="clu.phontools.alignment.parser.state.State.is_valid"><code class="name flex">
<span>def <span class="ident">is_valid</span></span>(<span>self, action: Actions) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"><p>Determines whether the provided action is valid</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def is_valid(self, action: Actions) -&gt; bool:
    &#34;&#34;&#34;Determines whether the provided action is valid&#34;&#34;&#34;
    res = self.perform_action(action)
    return False if not res else True</code></pre>
</details>
</dd>
<dt id="clu.phontools.alignment.parser.state.State.last_action"><code class="name flex">
<span>def <span class="ident">last_action</span></span>(<span>self) ‑> Union[<a title="clu.phontools.alignment.parser.actions.Actions" href="actions.html#clu.phontools.alignment.parser.actions.Actions">Actions</a>, NoneType]</span>
</code></dt>
<dd>
<div class="desc"><p>Easily access the last action applied</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def last_action(self) -&gt; Optional[Actions]:
    &#34;&#34;&#34;Easily access the last action applied&#34;&#34;&#34;
    return None if len(self.prior_actions) == 0 else self.prior_actions[-1]</code></pre>
</details>
</dd>
<dt id="clu.phontools.alignment.parser.state.State.perform_action"><code class="name flex">
<span>def <span class="ident">perform_action</span></span>(<span>self, action: Actions) ‑> Union[<a title="clu.phontools.alignment.parser.state.State" href="#clu.phontools.alignment.parser.state.State">State</a>, NoneType]</span>
</code></dt>
<dd>
<div class="desc"><p>Applies the provided action to the state</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def perform_action(self, action: Actions) -&gt; Optional[State]:
    &#34;&#34;&#34;Applies the provided action to the state&#34;&#34;&#34;
    actions_map = self.actions_map
    if action in actions_map:
        return actions_map[action]()
    raise NotImplementedError(f&#34;Action {action} not recognized&#34;)</code></pre>
</details>
</dd>
<dt id="clu.phontools.alignment.parser.state.State.valid_actions"><code class="name flex">
<span>def <span class="ident">valid_actions</span></span>(<span>self) ‑> List[Actions]</span>
</code></dt>
<dd>
<div class="desc"><p>Determines valid actions</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def valid_actions(self) -&gt; List[Actions]:
    &#34;&#34;&#34;Determines valid actions&#34;&#34;&#34;
    return [action for action in self.actions_map.keys() if self.is_valid(action)]</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="clu.phontools.alignment.parser" href="index.html">clu.phontools.alignment.parser</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="clu.phontools.alignment.parser.state.State" href="#clu.phontools.alignment.parser.state.State">State</a></code></h4>
<ul class="two-column">
<li><code><a title="clu.phontools.alignment.parser.state.State.actions_map" href="#clu.phontools.alignment.parser.state.State.actions_map">actions_map</a></code></li>
<li><code><a title="clu.phontools.alignment.parser.state.State.copy" href="#clu.phontools.alignment.parser.state.State.copy">copy</a></code></li>
<li><code><a title="clu.phontools.alignment.parser.state.State.current_graph" href="#clu.phontools.alignment.parser.state.State.current_graph">current_graph</a></code></li>
<li><code><a title="clu.phontools.alignment.parser.state.State.gold_graph" href="#clu.phontools.alignment.parser.state.State.gold_graph">gold_graph</a></code></li>
<li><code><a title="clu.phontools.alignment.parser.state.State.gold_queue" href="#clu.phontools.alignment.parser.state.State.gold_queue">gold_queue</a></code></li>
<li><code><a title="clu.phontools.alignment.parser.state.State.is_valid" href="#clu.phontools.alignment.parser.state.State.is_valid">is_valid</a></code></li>
<li><code><a title="clu.phontools.alignment.parser.state.State.last_action" href="#clu.phontools.alignment.parser.state.State.last_action">last_action</a></code></li>
<li><code><a title="clu.phontools.alignment.parser.state.State.perform_action" href="#clu.phontools.alignment.parser.state.State.perform_action">perform_action</a></code></li>
<li><code><a title="clu.phontools.alignment.parser.state.State.prior_actions" href="#clu.phontools.alignment.parser.state.State.prior_actions">prior_actions</a></code></li>
<li><code><a title="clu.phontools.alignment.parser.state.State.stack" href="#clu.phontools.alignment.parser.state.State.stack">stack</a></code></li>
<li><code><a title="clu.phontools.alignment.parser.state.State.transcribed_queue" href="#clu.phontools.alignment.parser.state.State.transcribed_queue">transcribed_queue</a></code></li>
<li><code><a title="clu.phontools.alignment.parser.state.State.valid_actions" href="#clu.phontools.alignment.parser.state.State.valid_actions">valid_actions</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.2</a>.</p>
</footer>
</body>
</html>