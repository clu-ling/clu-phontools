<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.2" />
<title>clu.phontools.struct API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS_CHTML" integrity="sha256-kZafAc6mZvK3W3v1pHOcUix30OHQN6pU/NO2oFkqZVw=" crossorigin></script>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>clu.phontools.struct</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">from enum import Enum
from abc import ABC, abstractmethod
from typing import List, Dict, Tuple, Any, Text, Sequence
import re
import itertools
from autocorrect import Speller
from pydantic import BaseModel
from pydantic.dataclasses import dataclass
import numpy as np


Pronunciation = Tuple[Text, ...]
Phone = Text
# type alias for a string of characters representing a word
SimpleWord = Text


spell = Speller(lang=&#34;en&#34;)


class Hashable(ABC):
    &#34;&#34;&#34;Ensures subclasses are hashable&#34;&#34;&#34;

    @abstractmethod
    def __hash__(self) -&gt; int:
        pass


class Stress(Enum):
    &#34;&#34;&#34;Enumeration of all possible stress values&#34;&#34;&#34;

    NON_VOWEL = &#34;-&#34;
    &#34;&#34;&#34;The phone is not a vowel (i.e., it cannot have a stress assignment)&#34;&#34;&#34;
    NO_STRESS = &#34;0&#34;
    &#34;&#34;&#34;The phone (vowel) is unstressed.&#34;&#34;&#34;
    PRIMARY = &#34;1&#34;
    &#34;&#34;&#34;The phone (vowel) receives primary stress&#34;&#34;&#34;
    SECONDARY = &#34;2&#34;
    &#34;&#34;&#34;The phone (vowel) receives secondary stress.&#34;&#34;&#34;

    def __repr__(self) -&gt; Text:
        return f&#34;Stress.{self.name}&#34;


class CoarseStress(Enum):
    &#34;&#34;&#34;A coarse representation of stress is categorized as being either strong (S) of weak (W).&#34;&#34;&#34;

    STRONG = &#34;S&#34;
    &#34;&#34;&#34;Strong stress.  Corresponds to `clu.phontools.struct.Stress.PRIMARY` and `clu.phontools.struct.Stress.SECONDARY`&#34;&#34;&#34;
    WEAK = &#34;W&#34;
    &#34;&#34;&#34;Weak stress.  Corresponds to `clu.phontools.struct.Stress.NO_STRESS`&#34;&#34;&#34;

    def __repr__(self) -&gt; Text:
        return f&#34;CoarseStress.{self.name}&#34;


class SyllableProperties(ABC):
    &#34;&#34;&#34;Propertie and manipulations of syllables.&#34;&#34;&#34;

    &#34;&#34;&#34;A sequence of `clu.phontools.struct.Stress` assignments&#34;&#34;&#34;

    def __init__(self):
        self.stress_pattern: Sequence[Stress] = []

    @property
    def coarse_stress_pattern(self) -&gt; Sequence[CoarseStress]:
        &#34;&#34;&#34;Maps a detailed stress sequence to a sequence of strong and weak stressed syllabled&#34;&#34;&#34;
        summary = []
        for stress in self.stress_pattern:
            if stress == Stress.NO_STRESS:
                summary.append(CoarseStress.WEAK)
            elif stress in {Stress.PRIMARY, Stress.SECONDARY}:
                summary.append(CoarseStress.STRONG)
        return summary

    @property
    def coarse_stress(self) -&gt; Text:
        &#34;&#34;&#34;Converts a phonological word to a sequence of S (strong) or W (weak) symbols&#34;&#34;&#34;
        return &#34;&#34;.join(cs.value for cs in self.coarse_stress_pattern)

    def mask_syllables(self, mask: Text = &#34;X&#34;) -&gt; Text:
        &#34;&#34;&#34;Converts a phonological word where each syllable is represented using the mask

        conceptual examples:
        &#34;poo&#34; -&gt; &#34;X&#34; where mask is &#34;X&#34;
        &#34;July&#34; -&gt; &#34;XX&#34; where mask is &#34;X&#34;
        &#34;&#34;&#34;
        return &#34;&#34;.join(mask for cs in self.coarse_stress_pattern)

    @property
    def num_syllables(self):
        &#34;&#34;&#34;A syllable contains at most one stressed element (weak or strong)&#34;&#34;&#34;
        return len(self.coarse_stress_pattern)


# FIXME: consider adding PhonologicalSystem(Enum) -&gt; ARPABET, IPA, XAMPA, etc.
class PhonologicalWord(BaseModel, SyllableProperties, Hashable):
    &#34;&#34;&#34;A [phonological word](https://en.wikipedia.org/wiki/Phonological_word) composed of one or more syllables

    :param phones: a sequences of phonological symbols (character, kana, etc.)
    :param stress_pattern: a sequence of `clu.phontools.struct.Stress` assignments (one for each of the `phones`)
    &#34;&#34;&#34;

    phones: Sequence[Phone]
    &#34;&#34;&#34;NOTE: For an EnglishSyllable, use `clu.phontools.lang.en.EnglishUtils.pronouncing_dict` as part of @staticmethod factory constructor&#34;&#34;&#34;
    stress_pattern: Sequence[Stress]

    def __iter__(self) -&gt; Phone:
        for phone in self.phones:
            yield phone

    def __getitem__(self, i: int) -&gt; Phone:
        return self.phones[i]

    def __reversed__(self) -&gt; &#34;Phrase&#34;:
        return PhonologicalWord(phones=self.phones[::-1])

    def __contains__(self, item) -&gt; bool:
        return True if item in self.phones else False

    def __len__(self) -&gt; int:
        return len(self.phones)

    def __hash__(self) -&gt; int:
        return hash(tuple(list(self.phones) + list(self.stress_pattern)))


class Word(BaseModel, Hashable):
    r&#34;&#34;&#34;The smallest sequence of phonemes that can be uttered in isolation with objective or practical meaning.

    :param word: orthographic representation of this Word
    :param phonological_form: the phonological form of this Word
    &#34;&#34;&#34;

    word: Text
    phonological_form: PhonologicalWord

    @property
    def pf(self) -&gt; PhonologicalWord:
        &#34;&#34;&#34;Alias for phonological_form&#34;&#34;&#34;
        return self.phonological_form

    def graphemes(self) -&gt; Sequence[Text]:
        &#34;&#34;&#34;Individual characters/symbols that comprise the orthographic representation of the `clu.phontools.struct.Word`&#34;&#34;&#34;
        return &#34;&#34;.split(self.word)

    def __hash__(self) -&gt; int:
        return hash(((&#34;word&#34;, self.word), (&#34;pf&#34;, hash(self.phonological_form))))


class Phrase(BaseModel, Hashable):
    &#34;&#34;&#34;A sequence of `clu.phontools.struct.Word` constitutes a Phrase.

    :param words: The sequence of `clu.phontools.struct.Word` that constitutes this Phrase.
    &#34;&#34;&#34;

    words: Sequence[Word]

    @property
    def coarse_stress(self) -&gt; Sequence[Text]:
        &#34;&#34;&#34;Returns coarse stress form for each word in the Phrase&#34;&#34;&#34;
        return [word.pf.coarse_stress for word in self.words]

    def mask_syllables(self, mask: Text = &#34;X&#34;) -&gt; Sequence[Text]:
        &#34;&#34;&#34;Returns coarse stress form for each word in the Phrase&#34;&#34;&#34;
        return [word.pf.mask_syllables(mask) for word in self.words]

    def words_as_phones(self) -&gt; Sequence[Text]:
        &#34;&#34;&#34;Represent `clu.phontools.struct.Phrase` using a sequence of symbols denoting the phones of each word

        Example:
        ```python
        from clu.phontools.struct import *
        # define a phrase
        phrase = Phrase(
          words=[
            Word(
              word=&#39;hello&#39;,
              phonological_form=PhonologicalWord(
                phones=(&#39;HH&#39;, &#39;EH0&#39;, &#39;L&#39;, &#39;OW1&#39;),
                stress_pattern=[
                  Stress.NON_VOWEL,
                  Stress.NO_STRESS,
                  Stress.NON_VOWEL,
                  Stress.PRIMARY
                ]
              )
            ),
            Word(
              word=&#39;world&#39;,
              phonological_form=PhonologicalWord(
                phones=(&#39;W&#39;, &#39;ER1&#39;, &#39;L&#39;, &#39;D&#39;),
                stress_pattern=[
                  Stress.NON_VOWEL,
                  Stress.PRIMARY,
                  Stress.NON_VOWEL,
                  Stress.NON_VOWEL
                ]
              )
            )
          ]
        )

        phrase.to_phones()
        # should return [&#39;HH EH0 L OW1&#39;, &#39;W ER1 L D&#39;]
        ```
        &#34;&#34;&#34;
        return [&#34; &#34;.join(word.pf.phones) for word in self.words]

    @property
    def phones(self) -&gt; Sequence[Text]:
        &#34;&#34;&#34;Represent `clu.phontools.struct.Phrase` using a flat sequence of symbols denoting the phones of each word

        Example:
        ```python
        from clu.phontools.struct import *
        # define a phrase
        phrase = Phrase(
          words=[
            Word(
              word=&#39;hello&#39;,
              phonological_form=PhonologicalWord(
                phones=(&#39;HH&#39;, &#39;EH0&#39;, &#39;L&#39;, &#39;OW1&#39;),
                stress_pattern=[
                  Stress.NON_VOWEL,
                  Stress.NO_STRESS,
                  Stress.NON_VOWEL,
                  Stress.PRIMARY
                ]
              )
            ),
            Word(
              word=&#39;world&#39;,
              phonological_form=PhonologicalWord(
                phones=(&#39;W&#39;, &#39;ER1&#39;, &#39;L&#39;, &#39;D&#39;),
                stress_pattern=[
                  Stress.NON_VOWEL,
                  Stress.PRIMARY,
                  Stress.NON_VOWEL,
                  Stress.NON_VOWEL
                ]
              )
            )
          ]
        )

        phrase.to_phones()
        # should return [&#34;HH&#34;, &#34;EH0&#34;, &#34;L&#34;, &#34;OW1&#34;, &#34;W&#34;, &#34;ER1&#34;, &#34;L&#34;, &#34;D&#34;]
        ```
        &#34;&#34;&#34;
        return [phone for word in self.words for phone in word.pf.phones]

    @property
    def coarse_stress_pattern(self) -&gt; Sequence[CoarseStress]:
        &#34;&#34;&#34;Returns coarse stress pattern for each word in the Phrase&#34;&#34;&#34;
        return [word.pf.coarse_stress_pattern for word in self.words]

    @property
    def stress_pattern(self) -&gt; Sequence[Stress]:
        &#34;&#34;&#34;Returns stress pattern for each word in the Phrase&#34;&#34;&#34;
        return [word.pf.stress_pattern for word in self.words]

    def match_coarse_stress_pattern(self, pattern: Text) -&gt; bool:
        &#34;&#34;&#34;Checks if `clu.phontools.struct.Phrase matches` the specified coarse stress pattern (a regular expression).

        Example:
        ```python
        from clu.phontools.struct import *
        # define a phrase
        phrase = Phrase(
          words=[
            Word(
              word=&#39;hello&#39;,
              phonological_form=PhonologicalWord(
                phones=(&#39;HH&#39;, &#39;EH0&#39;, &#39;L&#39;, &#39;OW1&#39;),
                stress_pattern=[
                  Stress.NON_VOWEL,
                  Stress.NO_STRESS,
                  Stress.NON_VOWEL,
                  Stress.PRIMARY
                ]
              )
            )
          ]
        )

        phrase.match_coarse_stress_pattern(&#34;WS&#34;)
        # should return True
        ```
        &#34;&#34;&#34;
        return True if re.match(pattern, &#34; &#34;.join(self.coarse_stress)) else False

    def match_masked_syllables(self, pattern: Text, mask: Text = &#34;X&#34;) -&gt; bool:
        &#34;&#34;&#34;Checks if `clu.phontools.struct.Phrase matches` the specified masked stress pattern (a regular expression).

        Example:
        ```python
        from clu.phontools.struct import *
        # define a phrase
        phrase = Phrase(
          words=[
            Word(
              word=&#39;hello&#39;,
              phonological_form=PhonologicalWord(
                phones=(&#39;HH&#39;, &#39;EH0&#39;, &#39;L&#39;, &#39;OW1&#39;),
                stress_pattern=[
                  Stress.NON_VOWEL,
                  Stress.NO_STRESS,
                  Stress.NON_VOWEL,
                  Stress.PRIMARY
                ]
              )
            )
          ]
        )

        phrase.match_masked_syllables(&#34;^XX&#34;, mask=&#34;X&#34;)
        # should return True
        ```
        &#34;&#34;&#34;
        return (
            True
            if re.match(pattern, &#34; &#34;.join(self.mask_syllables(mask=mask)))
            else False
        )

    def __iter__(self) -&gt; Word:
        for word in self.words:
            yield word

    def __getitem__(self, i: int) -&gt; Word:
        return self.words[i]

    def __reversed__(self) -&gt; &#34;Phrase&#34;:
        return Phrase(words=self.words[::-1])

    def __contains__(self, item) -&gt; bool:
        return True if item in self.words else False

    def __len__(self) -&gt; int:
        return len(self.words)

    def __hash__(self) -&gt; int:
        return hash(tuple(hash(w) for w in self.words))


class LangUtils(ABC):
    &#34;&#34;&#34;Utilities to be implemented for each language.&#34;&#34;&#34;

    @staticmethod
    @abstractmethod
    def phonological_word_for(phones: Pronunciation) -&gt; PhonologicalWord:
        &#34;&#34;&#34;Produces a `clu.phontools.struct.PhonologicalWord` for a sequence of phones&#34;&#34;&#34;
        pass

    @staticmethod
    @abstractmethod
    def all_possible_forms_for(word: Text) -&gt; Sequence[Word]:
        &#34;&#34;&#34;Generates a list of `clu.phontools.struct.Word` from an orthographic form.&#34;&#34;&#34;
        pass

    @staticmethod
    @abstractmethod
    def all_possible_phrases_for(words: Sequence[Text]) -&gt; Sequence[Phrase]:
        &#34;&#34;&#34;Generates a possible pronunciations from a sequence of words (as text).&#34;&#34;&#34;
        pass

    @staticmethod
    @abstractmethod
    def syllabify(pronunciation: Pronunciation) -&gt; Sequence[Pronunciation]:
        &#34;&#34;&#34;Abstract static method to syllabify a sequence of phones that constitute the pronunciation of a single lexical item.

        Example:
        A subclass that implements this method would ...
        ```python
        MyEnglishSyllabifier.syllabify((&#39;P&#39;, &#39;ER0&#39;, &#39;M&#39;, &#39;IH1&#39;, &#39;T&#39;))
        # should return [(&#39;P&#39;, &#39;ER0&#39;), (&#39;M&#39;, &#39;IH1&#39;, &#39;T&#39;)]
        ```
        &#34;&#34;&#34;
        pass


# class StressSequence:
#     &#34;&#34;&#34;A sequence of stress assignments.
#     &#34;&#34;&#34;
#     sequence: List[Stress]
#
# class SimpleStressSequence:
#    sequence:
# stress = [str(p.value) for p in pron]
# [&#39;-&#39;, &#39;0&#39;, &#39;-&#39;, &#39;1&#39;, &#39;-&#39;]
# syllable_structure =
# pron -&gt; stress -&gt; syllable counts
# [&#39;-&#39;, &#39;0&#39;, &#39;-&#39;, &#39;1&#39;, &#39;-&#39;] -&gt; &#34;WS&#34;
# First token has two syllables: Strong Weak
# [&#34;SW&#34;, &#34;S&#34;, &#34;W&#34;, &#34;SW&#34;]
# Each X represents a syllable
# [&#34;X&#34; ,&#34;X&#34; ,&#34;X&#34;, &#34;X&#34;, &#34;XX&#34;]
# mask_syllable_stress([&#34;SW&#34;, &#34;S&#34;, &#34;W&#34;, &#34;SW&#34;]) -&gt; [&#34;XX&#34;, &#34;X&#34;, &#34;X&#34;, &#34;XX&#34;]
# Output:
# second token of transcript (1) inserts before weak syllable
# [(1, &#34;IW&#34;)]</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="clu.phontools.struct.CoarseStress"><code class="flex name class">
<span>class <span class="ident">CoarseStress</span></span>
<span>(</span><span>value, names=None, *, module=None, qualname=None, type=None, start=1)</span>
</code></dt>
<dd>
<div class="desc"><p>A coarse representation of stress is categorized as being either strong (S) of weak (W).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class CoarseStress(Enum):
    &#34;&#34;&#34;A coarse representation of stress is categorized as being either strong (S) of weak (W).&#34;&#34;&#34;

    STRONG = &#34;S&#34;
    &#34;&#34;&#34;Strong stress.  Corresponds to `clu.phontools.struct.Stress.PRIMARY` and `clu.phontools.struct.Stress.SECONDARY`&#34;&#34;&#34;
    WEAK = &#34;W&#34;
    &#34;&#34;&#34;Weak stress.  Corresponds to `clu.phontools.struct.Stress.NO_STRESS`&#34;&#34;&#34;

    def __repr__(self) -&gt; Text:
        return f&#34;CoarseStress.{self.name}&#34;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>enum.Enum</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="clu.phontools.struct.CoarseStress.STRONG"><code class="name">var <span class="ident">STRONG</span></code></dt>
<dd>
<div class="desc"><p>Strong stress.
Corresponds to <code><a title="clu.phontools.struct.Stress.PRIMARY" href="#clu.phontools.struct.Stress.PRIMARY">Stress.PRIMARY</a></code> and <code><a title="clu.phontools.struct.Stress.SECONDARY" href="#clu.phontools.struct.Stress.SECONDARY">Stress.SECONDARY</a></code></p></div>
</dd>
<dt id="clu.phontools.struct.CoarseStress.WEAK"><code class="name">var <span class="ident">WEAK</span></code></dt>
<dd>
<div class="desc"><p>Weak stress.
Corresponds to <code><a title="clu.phontools.struct.Stress.NO_STRESS" href="#clu.phontools.struct.Stress.NO_STRESS">Stress.NO_STRESS</a></code></p></div>
</dd>
</dl>
</dd>
<dt id="clu.phontools.struct.Hashable"><code class="flex name class">
<span>class <span class="ident">Hashable</span></span>
</code></dt>
<dd>
<div class="desc"><p>Ensures subclasses are hashable</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Hashable(ABC):
    &#34;&#34;&#34;Ensures subclasses are hashable&#34;&#34;&#34;

    @abstractmethod
    def __hash__(self) -&gt; int:
        pass</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>abc.ABC</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="clu.phontools.struct.PhonologicalWord" href="#clu.phontools.struct.PhonologicalWord">PhonologicalWord</a></li>
<li><a title="clu.phontools.struct.Phrase" href="#clu.phontools.struct.Phrase">Phrase</a></li>
<li><a title="clu.phontools.struct.Word" href="#clu.phontools.struct.Word">Word</a></li>
</ul>
</dd>
<dt id="clu.phontools.struct.LangUtils"><code class="flex name class">
<span>class <span class="ident">LangUtils</span></span>
</code></dt>
<dd>
<div class="desc"><p>Utilities to be implemented for each language.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class LangUtils(ABC):
    &#34;&#34;&#34;Utilities to be implemented for each language.&#34;&#34;&#34;

    @staticmethod
    @abstractmethod
    def phonological_word_for(phones: Pronunciation) -&gt; PhonologicalWord:
        &#34;&#34;&#34;Produces a `clu.phontools.struct.PhonologicalWord` for a sequence of phones&#34;&#34;&#34;
        pass

    @staticmethod
    @abstractmethod
    def all_possible_forms_for(word: Text) -&gt; Sequence[Word]:
        &#34;&#34;&#34;Generates a list of `clu.phontools.struct.Word` from an orthographic form.&#34;&#34;&#34;
        pass

    @staticmethod
    @abstractmethod
    def all_possible_phrases_for(words: Sequence[Text]) -&gt; Sequence[Phrase]:
        &#34;&#34;&#34;Generates a possible pronunciations from a sequence of words (as text).&#34;&#34;&#34;
        pass

    @staticmethod
    @abstractmethod
    def syllabify(pronunciation: Pronunciation) -&gt; Sequence[Pronunciation]:
        &#34;&#34;&#34;Abstract static method to syllabify a sequence of phones that constitute the pronunciation of a single lexical item.

        Example:
        A subclass that implements this method would ...
        ```python
        MyEnglishSyllabifier.syllabify((&#39;P&#39;, &#39;ER0&#39;, &#39;M&#39;, &#39;IH1&#39;, &#39;T&#39;))
        # should return [(&#39;P&#39;, &#39;ER0&#39;), (&#39;M&#39;, &#39;IH1&#39;, &#39;T&#39;)]
        ```
        &#34;&#34;&#34;
        pass</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>abc.ABC</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="clu.phontools.lang.en.EnglishUtils" href="lang/en.html#clu.phontools.lang.en.EnglishUtils">EnglishUtils</a></li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="clu.phontools.struct.LangUtils.all_possible_forms_for"><code class="name flex">
<span>def <span class="ident">all_possible_forms_for</span></span>(<span>word: str) ‑> Sequence[<a title="clu.phontools.struct.Word" href="#clu.phontools.struct.Word">Word</a>]</span>
</code></dt>
<dd>
<div class="desc"><p>Generates a list of <code><a title="clu.phontools.struct.Word" href="#clu.phontools.struct.Word">Word</a></code> from an orthographic form.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
@abstractmethod
def all_possible_forms_for(word: Text) -&gt; Sequence[Word]:
    &#34;&#34;&#34;Generates a list of `clu.phontools.struct.Word` from an orthographic form.&#34;&#34;&#34;
    pass</code></pre>
</details>
</dd>
<dt id="clu.phontools.struct.LangUtils.all_possible_phrases_for"><code class="name flex">
<span>def <span class="ident">all_possible_phrases_for</span></span>(<span>words: Sequence[str]) ‑> Sequence[<a title="clu.phontools.struct.Phrase" href="#clu.phontools.struct.Phrase">Phrase</a>]</span>
</code></dt>
<dd>
<div class="desc"><p>Generates a possible pronunciations from a sequence of words (as text).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
@abstractmethod
def all_possible_phrases_for(words: Sequence[Text]) -&gt; Sequence[Phrase]:
    &#34;&#34;&#34;Generates a possible pronunciations from a sequence of words (as text).&#34;&#34;&#34;
    pass</code></pre>
</details>
</dd>
<dt id="clu.phontools.struct.LangUtils.phonological_word_for"><code class="name flex">
<span>def <span class="ident">phonological_word_for</span></span>(<span>phones: Tuple[str, ...]) ‑> <a title="clu.phontools.struct.PhonologicalWord" href="#clu.phontools.struct.PhonologicalWord">PhonologicalWord</a></span>
</code></dt>
<dd>
<div class="desc"><p>Produces a <code><a title="clu.phontools.struct.PhonologicalWord" href="#clu.phontools.struct.PhonologicalWord">PhonologicalWord</a></code> for a sequence of phones</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
@abstractmethod
def phonological_word_for(phones: Pronunciation) -&gt; PhonologicalWord:
    &#34;&#34;&#34;Produces a `clu.phontools.struct.PhonologicalWord` for a sequence of phones&#34;&#34;&#34;
    pass</code></pre>
</details>
</dd>
<dt id="clu.phontools.struct.LangUtils.syllabify"><code class="name flex">
<span>def <span class="ident">syllabify</span></span>(<span>pronunciation: Tuple[str, ...]) ‑> Sequence[Tuple[str, ...]]</span>
</code></dt>
<dd>
<div class="desc"><p>Abstract static method to syllabify a sequence of phones that constitute the pronunciation of a single lexical item.</p>
<p>Example:
A subclass that implements this method would &hellip;</p>
<pre><code class="language-python">MyEnglishSyllabifier.syllabify(('P', 'ER0', 'M', 'IH1', 'T'))
# should return [('P', 'ER0'), ('M', 'IH1', 'T')]
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
@abstractmethod
def syllabify(pronunciation: Pronunciation) -&gt; Sequence[Pronunciation]:
    &#34;&#34;&#34;Abstract static method to syllabify a sequence of phones that constitute the pronunciation of a single lexical item.

    Example:
    A subclass that implements this method would ...
    ```python
    MyEnglishSyllabifier.syllabify((&#39;P&#39;, &#39;ER0&#39;, &#39;M&#39;, &#39;IH1&#39;, &#39;T&#39;))
    # should return [(&#39;P&#39;, &#39;ER0&#39;), (&#39;M&#39;, &#39;IH1&#39;, &#39;T&#39;)]
    ```
    &#34;&#34;&#34;
    pass</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="clu.phontools.struct.PhonologicalWord"><code class="flex name class">
<span>class <span class="ident">PhonologicalWord</span></span>
<span>(</span><span>**data: Any)</span>
</code></dt>
<dd>
<div class="desc"><p>A <a href="https://en.wikipedia.org/wiki/Phonological_word">phonological word</a> composed of one or more syllables</p>
<p>:param phones: a sequences of phonological symbols (character, kana, etc.)
:param stress_pattern: a sequence of <code><a title="clu.phontools.struct.Stress" href="#clu.phontools.struct.Stress">Stress</a></code> assignments (one for each of the <code>phones</code>)</p>
<p>Create a new model by parsing and validating input data from keyword arguments.</p>
<p>Raises ValidationError if the input data cannot be parsed to form a valid model.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class PhonologicalWord(BaseModel, SyllableProperties, Hashable):
    &#34;&#34;&#34;A [phonological word](https://en.wikipedia.org/wiki/Phonological_word) composed of one or more syllables

    :param phones: a sequences of phonological symbols (character, kana, etc.)
    :param stress_pattern: a sequence of `clu.phontools.struct.Stress` assignments (one for each of the `phones`)
    &#34;&#34;&#34;

    phones: Sequence[Phone]
    &#34;&#34;&#34;NOTE: For an EnglishSyllable, use `clu.phontools.lang.en.EnglishUtils.pronouncing_dict` as part of @staticmethod factory constructor&#34;&#34;&#34;
    stress_pattern: Sequence[Stress]

    def __iter__(self) -&gt; Phone:
        for phone in self.phones:
            yield phone

    def __getitem__(self, i: int) -&gt; Phone:
        return self.phones[i]

    def __reversed__(self) -&gt; &#34;Phrase&#34;:
        return PhonologicalWord(phones=self.phones[::-1])

    def __contains__(self, item) -&gt; bool:
        return True if item in self.phones else False

    def __len__(self) -&gt; int:
        return len(self.phones)

    def __hash__(self) -&gt; int:
        return hash(tuple(list(self.phones) + list(self.stress_pattern)))</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>pydantic.main.BaseModel</li>
<li>pydantic.utils.Representation</li>
<li><a title="clu.phontools.struct.SyllableProperties" href="#clu.phontools.struct.SyllableProperties">SyllableProperties</a></li>
<li><a title="clu.phontools.struct.Hashable" href="#clu.phontools.struct.Hashable">Hashable</a></li>
<li>abc.ABC</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="clu.phontools.struct.PhonologicalWord.phones"><code class="name">var <span class="ident">phones</span> : Sequence[str]</code></dt>
<dd>
<div class="desc"><p>NOTE: For an EnglishSyllable, use <code><a title="clu.phontools.lang.en.EnglishUtils.pronouncing_dict" href="lang/en.html#clu.phontools.lang.en.EnglishUtils.pronouncing_dict">EnglishUtils.pronouncing_dict</a></code> as part of @staticmethod factory constructor</p></div>
</dd>
<dt id="clu.phontools.struct.PhonologicalWord.stress_pattern"><code class="name">var <span class="ident">stress_pattern</span> : Sequence[<a title="clu.phontools.struct.Stress" href="#clu.phontools.struct.Stress">Stress</a>]</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="clu.phontools.struct.SyllableProperties" href="#clu.phontools.struct.SyllableProperties">SyllableProperties</a></b></code>:
<ul class="hlist">
<li><code><a title="clu.phontools.struct.SyllableProperties.coarse_stress" href="#clu.phontools.struct.SyllableProperties.coarse_stress">coarse_stress</a></code></li>
<li><code><a title="clu.phontools.struct.SyllableProperties.coarse_stress_pattern" href="#clu.phontools.struct.SyllableProperties.coarse_stress_pattern">coarse_stress_pattern</a></code></li>
<li><code><a title="clu.phontools.struct.SyllableProperties.mask_syllables" href="#clu.phontools.struct.SyllableProperties.mask_syllables">mask_syllables</a></code></li>
<li><code><a title="clu.phontools.struct.SyllableProperties.num_syllables" href="#clu.phontools.struct.SyllableProperties.num_syllables">num_syllables</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="clu.phontools.struct.Phrase"><code class="flex name class">
<span>class <span class="ident">Phrase</span></span>
<span>(</span><span>**data: Any)</span>
</code></dt>
<dd>
<div class="desc"><p>A sequence of <code><a title="clu.phontools.struct.Word" href="#clu.phontools.struct.Word">Word</a></code> constitutes a Phrase.</p>
<p>:param words: The sequence of <code><a title="clu.phontools.struct.Word" href="#clu.phontools.struct.Word">Word</a></code> that constitutes this Phrase.</p>
<p>Create a new model by parsing and validating input data from keyword arguments.</p>
<p>Raises ValidationError if the input data cannot be parsed to form a valid model.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Phrase(BaseModel, Hashable):
    &#34;&#34;&#34;A sequence of `clu.phontools.struct.Word` constitutes a Phrase.

    :param words: The sequence of `clu.phontools.struct.Word` that constitutes this Phrase.
    &#34;&#34;&#34;

    words: Sequence[Word]

    @property
    def coarse_stress(self) -&gt; Sequence[Text]:
        &#34;&#34;&#34;Returns coarse stress form for each word in the Phrase&#34;&#34;&#34;
        return [word.pf.coarse_stress for word in self.words]

    def mask_syllables(self, mask: Text = &#34;X&#34;) -&gt; Sequence[Text]:
        &#34;&#34;&#34;Returns coarse stress form for each word in the Phrase&#34;&#34;&#34;
        return [word.pf.mask_syllables(mask) for word in self.words]

    def words_as_phones(self) -&gt; Sequence[Text]:
        &#34;&#34;&#34;Represent `clu.phontools.struct.Phrase` using a sequence of symbols denoting the phones of each word

        Example:
        ```python
        from clu.phontools.struct import *
        # define a phrase
        phrase = Phrase(
          words=[
            Word(
              word=&#39;hello&#39;,
              phonological_form=PhonologicalWord(
                phones=(&#39;HH&#39;, &#39;EH0&#39;, &#39;L&#39;, &#39;OW1&#39;),
                stress_pattern=[
                  Stress.NON_VOWEL,
                  Stress.NO_STRESS,
                  Stress.NON_VOWEL,
                  Stress.PRIMARY
                ]
              )
            ),
            Word(
              word=&#39;world&#39;,
              phonological_form=PhonologicalWord(
                phones=(&#39;W&#39;, &#39;ER1&#39;, &#39;L&#39;, &#39;D&#39;),
                stress_pattern=[
                  Stress.NON_VOWEL,
                  Stress.PRIMARY,
                  Stress.NON_VOWEL,
                  Stress.NON_VOWEL
                ]
              )
            )
          ]
        )

        phrase.to_phones()
        # should return [&#39;HH EH0 L OW1&#39;, &#39;W ER1 L D&#39;]
        ```
        &#34;&#34;&#34;
        return [&#34; &#34;.join(word.pf.phones) for word in self.words]

    @property
    def phones(self) -&gt; Sequence[Text]:
        &#34;&#34;&#34;Represent `clu.phontools.struct.Phrase` using a flat sequence of symbols denoting the phones of each word

        Example:
        ```python
        from clu.phontools.struct import *
        # define a phrase
        phrase = Phrase(
          words=[
            Word(
              word=&#39;hello&#39;,
              phonological_form=PhonologicalWord(
                phones=(&#39;HH&#39;, &#39;EH0&#39;, &#39;L&#39;, &#39;OW1&#39;),
                stress_pattern=[
                  Stress.NON_VOWEL,
                  Stress.NO_STRESS,
                  Stress.NON_VOWEL,
                  Stress.PRIMARY
                ]
              )
            ),
            Word(
              word=&#39;world&#39;,
              phonological_form=PhonologicalWord(
                phones=(&#39;W&#39;, &#39;ER1&#39;, &#39;L&#39;, &#39;D&#39;),
                stress_pattern=[
                  Stress.NON_VOWEL,
                  Stress.PRIMARY,
                  Stress.NON_VOWEL,
                  Stress.NON_VOWEL
                ]
              )
            )
          ]
        )

        phrase.to_phones()
        # should return [&#34;HH&#34;, &#34;EH0&#34;, &#34;L&#34;, &#34;OW1&#34;, &#34;W&#34;, &#34;ER1&#34;, &#34;L&#34;, &#34;D&#34;]
        ```
        &#34;&#34;&#34;
        return [phone for word in self.words for phone in word.pf.phones]

    @property
    def coarse_stress_pattern(self) -&gt; Sequence[CoarseStress]:
        &#34;&#34;&#34;Returns coarse stress pattern for each word in the Phrase&#34;&#34;&#34;
        return [word.pf.coarse_stress_pattern for word in self.words]

    @property
    def stress_pattern(self) -&gt; Sequence[Stress]:
        &#34;&#34;&#34;Returns stress pattern for each word in the Phrase&#34;&#34;&#34;
        return [word.pf.stress_pattern for word in self.words]

    def match_coarse_stress_pattern(self, pattern: Text) -&gt; bool:
        &#34;&#34;&#34;Checks if `clu.phontools.struct.Phrase matches` the specified coarse stress pattern (a regular expression).

        Example:
        ```python
        from clu.phontools.struct import *
        # define a phrase
        phrase = Phrase(
          words=[
            Word(
              word=&#39;hello&#39;,
              phonological_form=PhonologicalWord(
                phones=(&#39;HH&#39;, &#39;EH0&#39;, &#39;L&#39;, &#39;OW1&#39;),
                stress_pattern=[
                  Stress.NON_VOWEL,
                  Stress.NO_STRESS,
                  Stress.NON_VOWEL,
                  Stress.PRIMARY
                ]
              )
            )
          ]
        )

        phrase.match_coarse_stress_pattern(&#34;WS&#34;)
        # should return True
        ```
        &#34;&#34;&#34;
        return True if re.match(pattern, &#34; &#34;.join(self.coarse_stress)) else False

    def match_masked_syllables(self, pattern: Text, mask: Text = &#34;X&#34;) -&gt; bool:
        &#34;&#34;&#34;Checks if `clu.phontools.struct.Phrase matches` the specified masked stress pattern (a regular expression).

        Example:
        ```python
        from clu.phontools.struct import *
        # define a phrase
        phrase = Phrase(
          words=[
            Word(
              word=&#39;hello&#39;,
              phonological_form=PhonologicalWord(
                phones=(&#39;HH&#39;, &#39;EH0&#39;, &#39;L&#39;, &#39;OW1&#39;),
                stress_pattern=[
                  Stress.NON_VOWEL,
                  Stress.NO_STRESS,
                  Stress.NON_VOWEL,
                  Stress.PRIMARY
                ]
              )
            )
          ]
        )

        phrase.match_masked_syllables(&#34;^XX&#34;, mask=&#34;X&#34;)
        # should return True
        ```
        &#34;&#34;&#34;
        return (
            True
            if re.match(pattern, &#34; &#34;.join(self.mask_syllables(mask=mask)))
            else False
        )

    def __iter__(self) -&gt; Word:
        for word in self.words:
            yield word

    def __getitem__(self, i: int) -&gt; Word:
        return self.words[i]

    def __reversed__(self) -&gt; &#34;Phrase&#34;:
        return Phrase(words=self.words[::-1])

    def __contains__(self, item) -&gt; bool:
        return True if item in self.words else False

    def __len__(self) -&gt; int:
        return len(self.words)

    def __hash__(self) -&gt; int:
        return hash(tuple(hash(w) for w in self.words))</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>pydantic.main.BaseModel</li>
<li>pydantic.utils.Representation</li>
<li><a title="clu.phontools.struct.Hashable" href="#clu.phontools.struct.Hashable">Hashable</a></li>
<li>abc.ABC</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="clu.phontools.struct.Phrase.words"><code class="name">var <span class="ident">words</span> : Sequence[<a title="clu.phontools.struct.Word" href="#clu.phontools.struct.Word">Word</a>]</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="clu.phontools.struct.Phrase.coarse_stress"><code class="name">var <span class="ident">coarse_stress</span> : Sequence[str]</code></dt>
<dd>
<div class="desc"><p>Returns coarse stress form for each word in the Phrase</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def coarse_stress(self) -&gt; Sequence[Text]:
    &#34;&#34;&#34;Returns coarse stress form for each word in the Phrase&#34;&#34;&#34;
    return [word.pf.coarse_stress for word in self.words]</code></pre>
</details>
</dd>
<dt id="clu.phontools.struct.Phrase.coarse_stress_pattern"><code class="name">var <span class="ident">coarse_stress_pattern</span> : Sequence[<a title="clu.phontools.struct.CoarseStress" href="#clu.phontools.struct.CoarseStress">CoarseStress</a>]</code></dt>
<dd>
<div class="desc"><p>Returns coarse stress pattern for each word in the Phrase</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def coarse_stress_pattern(self) -&gt; Sequence[CoarseStress]:
    &#34;&#34;&#34;Returns coarse stress pattern for each word in the Phrase&#34;&#34;&#34;
    return [word.pf.coarse_stress_pattern for word in self.words]</code></pre>
</details>
</dd>
<dt id="clu.phontools.struct.Phrase.phones"><code class="name">var <span class="ident">phones</span> : Sequence[str]</code></dt>
<dd>
<div class="desc"><p>Represent <code><a title="clu.phontools.struct.Phrase" href="#clu.phontools.struct.Phrase">Phrase</a></code> using a flat sequence of symbols denoting the phones of each word</p>
<p>Example:</p>
<pre><code class="language-python">from clu.phontools.struct import *
# define a phrase
phrase = Phrase(
  words=[
    Word(
      word='hello',
      phonological_form=PhonologicalWord(
        phones=('HH', 'EH0', 'L', 'OW1'),
        stress_pattern=[
          Stress.NON_VOWEL,
          Stress.NO_STRESS,
          Stress.NON_VOWEL,
          Stress.PRIMARY
        ]
      )
    ),
    Word(
      word='world',
      phonological_form=PhonologicalWord(
        phones=('W', 'ER1', 'L', 'D'),
        stress_pattern=[
          Stress.NON_VOWEL,
          Stress.PRIMARY,
          Stress.NON_VOWEL,
          Stress.NON_VOWEL
        ]
      )
    )
  ]
)

phrase.to_phones()
# should return [&quot;HH&quot;, &quot;EH0&quot;, &quot;L&quot;, &quot;OW1&quot;, &quot;W&quot;, &quot;ER1&quot;, &quot;L&quot;, &quot;D&quot;]
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def phones(self) -&gt; Sequence[Text]:
    &#34;&#34;&#34;Represent `clu.phontools.struct.Phrase` using a flat sequence of symbols denoting the phones of each word

    Example:
    ```python
    from clu.phontools.struct import *
    # define a phrase
    phrase = Phrase(
      words=[
        Word(
          word=&#39;hello&#39;,
          phonological_form=PhonologicalWord(
            phones=(&#39;HH&#39;, &#39;EH0&#39;, &#39;L&#39;, &#39;OW1&#39;),
            stress_pattern=[
              Stress.NON_VOWEL,
              Stress.NO_STRESS,
              Stress.NON_VOWEL,
              Stress.PRIMARY
            ]
          )
        ),
        Word(
          word=&#39;world&#39;,
          phonological_form=PhonologicalWord(
            phones=(&#39;W&#39;, &#39;ER1&#39;, &#39;L&#39;, &#39;D&#39;),
            stress_pattern=[
              Stress.NON_VOWEL,
              Stress.PRIMARY,
              Stress.NON_VOWEL,
              Stress.NON_VOWEL
            ]
          )
        )
      ]
    )

    phrase.to_phones()
    # should return [&#34;HH&#34;, &#34;EH0&#34;, &#34;L&#34;, &#34;OW1&#34;, &#34;W&#34;, &#34;ER1&#34;, &#34;L&#34;, &#34;D&#34;]
    ```
    &#34;&#34;&#34;
    return [phone for word in self.words for phone in word.pf.phones]</code></pre>
</details>
</dd>
<dt id="clu.phontools.struct.Phrase.stress_pattern"><code class="name">var <span class="ident">stress_pattern</span> : Sequence[<a title="clu.phontools.struct.Stress" href="#clu.phontools.struct.Stress">Stress</a>]</code></dt>
<dd>
<div class="desc"><p>Returns stress pattern for each word in the Phrase</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def stress_pattern(self) -&gt; Sequence[Stress]:
    &#34;&#34;&#34;Returns stress pattern for each word in the Phrase&#34;&#34;&#34;
    return [word.pf.stress_pattern for word in self.words]</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="clu.phontools.struct.Phrase.mask_syllables"><code class="name flex">
<span>def <span class="ident">mask_syllables</span></span>(<span>self, mask: str = 'X') ‑> Sequence[str]</span>
</code></dt>
<dd>
<div class="desc"><p>Returns coarse stress form for each word in the Phrase</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def mask_syllables(self, mask: Text = &#34;X&#34;) -&gt; Sequence[Text]:
    &#34;&#34;&#34;Returns coarse stress form for each word in the Phrase&#34;&#34;&#34;
    return [word.pf.mask_syllables(mask) for word in self.words]</code></pre>
</details>
</dd>
<dt id="clu.phontools.struct.Phrase.match_coarse_stress_pattern"><code class="name flex">
<span>def <span class="ident">match_coarse_stress_pattern</span></span>(<span>self, pattern: str) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"><p>Checks if <code><a title="clu.phontools.struct.Phrase" href="#clu.phontools.struct.Phrase">Phrase</a> matches</code> the specified coarse stress pattern (a regular expression).</p>
<p>Example:</p>
<pre><code class="language-python">from clu.phontools.struct import *
# define a phrase
phrase = Phrase(
  words=[
    Word(
      word='hello',
      phonological_form=PhonologicalWord(
        phones=('HH', 'EH0', 'L', 'OW1'),
        stress_pattern=[
          Stress.NON_VOWEL,
          Stress.NO_STRESS,
          Stress.NON_VOWEL,
          Stress.PRIMARY
        ]
      )
    )
  ]
)

phrase.match_coarse_stress_pattern(&quot;WS&quot;)
# should return True
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def match_coarse_stress_pattern(self, pattern: Text) -&gt; bool:
    &#34;&#34;&#34;Checks if `clu.phontools.struct.Phrase matches` the specified coarse stress pattern (a regular expression).

    Example:
    ```python
    from clu.phontools.struct import *
    # define a phrase
    phrase = Phrase(
      words=[
        Word(
          word=&#39;hello&#39;,
          phonological_form=PhonologicalWord(
            phones=(&#39;HH&#39;, &#39;EH0&#39;, &#39;L&#39;, &#39;OW1&#39;),
            stress_pattern=[
              Stress.NON_VOWEL,
              Stress.NO_STRESS,
              Stress.NON_VOWEL,
              Stress.PRIMARY
            ]
          )
        )
      ]
    )

    phrase.match_coarse_stress_pattern(&#34;WS&#34;)
    # should return True
    ```
    &#34;&#34;&#34;
    return True if re.match(pattern, &#34; &#34;.join(self.coarse_stress)) else False</code></pre>
</details>
</dd>
<dt id="clu.phontools.struct.Phrase.match_masked_syllables"><code class="name flex">
<span>def <span class="ident">match_masked_syllables</span></span>(<span>self, pattern: str, mask: str = 'X') ‑> bool</span>
</code></dt>
<dd>
<div class="desc"><p>Checks if <code><a title="clu.phontools.struct.Phrase" href="#clu.phontools.struct.Phrase">Phrase</a> matches</code> the specified masked stress pattern (a regular expression).</p>
<p>Example:</p>
<pre><code class="language-python">from clu.phontools.struct import *
# define a phrase
phrase = Phrase(
  words=[
    Word(
      word='hello',
      phonological_form=PhonologicalWord(
        phones=('HH', 'EH0', 'L', 'OW1'),
        stress_pattern=[
          Stress.NON_VOWEL,
          Stress.NO_STRESS,
          Stress.NON_VOWEL,
          Stress.PRIMARY
        ]
      )
    )
  ]
)

phrase.match_masked_syllables(&quot;^XX&quot;, mask=&quot;X&quot;)
# should return True
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def match_masked_syllables(self, pattern: Text, mask: Text = &#34;X&#34;) -&gt; bool:
    &#34;&#34;&#34;Checks if `clu.phontools.struct.Phrase matches` the specified masked stress pattern (a regular expression).

    Example:
    ```python
    from clu.phontools.struct import *
    # define a phrase
    phrase = Phrase(
      words=[
        Word(
          word=&#39;hello&#39;,
          phonological_form=PhonologicalWord(
            phones=(&#39;HH&#39;, &#39;EH0&#39;, &#39;L&#39;, &#39;OW1&#39;),
            stress_pattern=[
              Stress.NON_VOWEL,
              Stress.NO_STRESS,
              Stress.NON_VOWEL,
              Stress.PRIMARY
            ]
          )
        )
      ]
    )

    phrase.match_masked_syllables(&#34;^XX&#34;, mask=&#34;X&#34;)
    # should return True
    ```
    &#34;&#34;&#34;
    return (
        True
        if re.match(pattern, &#34; &#34;.join(self.mask_syllables(mask=mask)))
        else False
    )</code></pre>
</details>
</dd>
<dt id="clu.phontools.struct.Phrase.words_as_phones"><code class="name flex">
<span>def <span class="ident">words_as_phones</span></span>(<span>self) ‑> Sequence[str]</span>
</code></dt>
<dd>
<div class="desc"><p>Represent <code><a title="clu.phontools.struct.Phrase" href="#clu.phontools.struct.Phrase">Phrase</a></code> using a sequence of symbols denoting the phones of each word</p>
<p>Example:</p>
<pre><code class="language-python">from clu.phontools.struct import *
# define a phrase
phrase = Phrase(
  words=[
    Word(
      word='hello',
      phonological_form=PhonologicalWord(
        phones=('HH', 'EH0', 'L', 'OW1'),
        stress_pattern=[
          Stress.NON_VOWEL,
          Stress.NO_STRESS,
          Stress.NON_VOWEL,
          Stress.PRIMARY
        ]
      )
    ),
    Word(
      word='world',
      phonological_form=PhonologicalWord(
        phones=('W', 'ER1', 'L', 'D'),
        stress_pattern=[
          Stress.NON_VOWEL,
          Stress.PRIMARY,
          Stress.NON_VOWEL,
          Stress.NON_VOWEL
        ]
      )
    )
  ]
)

phrase.to_phones()
# should return ['HH EH0 L OW1', 'W ER1 L D']
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def words_as_phones(self) -&gt; Sequence[Text]:
    &#34;&#34;&#34;Represent `clu.phontools.struct.Phrase` using a sequence of symbols denoting the phones of each word

    Example:
    ```python
    from clu.phontools.struct import *
    # define a phrase
    phrase = Phrase(
      words=[
        Word(
          word=&#39;hello&#39;,
          phonological_form=PhonologicalWord(
            phones=(&#39;HH&#39;, &#39;EH0&#39;, &#39;L&#39;, &#39;OW1&#39;),
            stress_pattern=[
              Stress.NON_VOWEL,
              Stress.NO_STRESS,
              Stress.NON_VOWEL,
              Stress.PRIMARY
            ]
          )
        ),
        Word(
          word=&#39;world&#39;,
          phonological_form=PhonologicalWord(
            phones=(&#39;W&#39;, &#39;ER1&#39;, &#39;L&#39;, &#39;D&#39;),
            stress_pattern=[
              Stress.NON_VOWEL,
              Stress.PRIMARY,
              Stress.NON_VOWEL,
              Stress.NON_VOWEL
            ]
          )
        )
      ]
    )

    phrase.to_phones()
    # should return [&#39;HH EH0 L OW1&#39;, &#39;W ER1 L D&#39;]
    ```
    &#34;&#34;&#34;
    return [&#34; &#34;.join(word.pf.phones) for word in self.words]</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="clu.phontools.struct.Stress"><code class="flex name class">
<span>class <span class="ident">Stress</span></span>
<span>(</span><span>value, names=None, *, module=None, qualname=None, type=None, start=1)</span>
</code></dt>
<dd>
<div class="desc"><p>Enumeration of all possible stress values</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Stress(Enum):
    &#34;&#34;&#34;Enumeration of all possible stress values&#34;&#34;&#34;

    NON_VOWEL = &#34;-&#34;
    &#34;&#34;&#34;The phone is not a vowel (i.e., it cannot have a stress assignment)&#34;&#34;&#34;
    NO_STRESS = &#34;0&#34;
    &#34;&#34;&#34;The phone (vowel) is unstressed.&#34;&#34;&#34;
    PRIMARY = &#34;1&#34;
    &#34;&#34;&#34;The phone (vowel) receives primary stress&#34;&#34;&#34;
    SECONDARY = &#34;2&#34;
    &#34;&#34;&#34;The phone (vowel) receives secondary stress.&#34;&#34;&#34;

    def __repr__(self) -&gt; Text:
        return f&#34;Stress.{self.name}&#34;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>enum.Enum</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="clu.phontools.struct.Stress.NON_VOWEL"><code class="name">var <span class="ident">NON_VOWEL</span></code></dt>
<dd>
<div class="desc"><p>The phone is not a vowel (i.e., it cannot have a stress assignment)</p></div>
</dd>
<dt id="clu.phontools.struct.Stress.NO_STRESS"><code class="name">var <span class="ident">NO_STRESS</span></code></dt>
<dd>
<div class="desc"><p>The phone (vowel) is unstressed.</p></div>
</dd>
<dt id="clu.phontools.struct.Stress.PRIMARY"><code class="name">var <span class="ident">PRIMARY</span></code></dt>
<dd>
<div class="desc"><p>The phone (vowel) receives primary stress</p></div>
</dd>
<dt id="clu.phontools.struct.Stress.SECONDARY"><code class="name">var <span class="ident">SECONDARY</span></code></dt>
<dd>
<div class="desc"><p>The phone (vowel) receives secondary stress.</p></div>
</dd>
</dl>
</dd>
<dt id="clu.phontools.struct.SyllableProperties"><code class="flex name class">
<span>class <span class="ident">SyllableProperties</span></span>
</code></dt>
<dd>
<div class="desc"><p>Propertie and manipulations of syllables.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class SyllableProperties(ABC):
    &#34;&#34;&#34;Propertie and manipulations of syllables.&#34;&#34;&#34;

    &#34;&#34;&#34;A sequence of `clu.phontools.struct.Stress` assignments&#34;&#34;&#34;

    def __init__(self):
        self.stress_pattern: Sequence[Stress] = []

    @property
    def coarse_stress_pattern(self) -&gt; Sequence[CoarseStress]:
        &#34;&#34;&#34;Maps a detailed stress sequence to a sequence of strong and weak stressed syllabled&#34;&#34;&#34;
        summary = []
        for stress in self.stress_pattern:
            if stress == Stress.NO_STRESS:
                summary.append(CoarseStress.WEAK)
            elif stress in {Stress.PRIMARY, Stress.SECONDARY}:
                summary.append(CoarseStress.STRONG)
        return summary

    @property
    def coarse_stress(self) -&gt; Text:
        &#34;&#34;&#34;Converts a phonological word to a sequence of S (strong) or W (weak) symbols&#34;&#34;&#34;
        return &#34;&#34;.join(cs.value for cs in self.coarse_stress_pattern)

    def mask_syllables(self, mask: Text = &#34;X&#34;) -&gt; Text:
        &#34;&#34;&#34;Converts a phonological word where each syllable is represented using the mask

        conceptual examples:
        &#34;poo&#34; -&gt; &#34;X&#34; where mask is &#34;X&#34;
        &#34;July&#34; -&gt; &#34;XX&#34; where mask is &#34;X&#34;
        &#34;&#34;&#34;
        return &#34;&#34;.join(mask for cs in self.coarse_stress_pattern)

    @property
    def num_syllables(self):
        &#34;&#34;&#34;A syllable contains at most one stressed element (weak or strong)&#34;&#34;&#34;
        return len(self.coarse_stress_pattern)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>abc.ABC</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="clu.phontools.struct.PhonologicalWord" href="#clu.phontools.struct.PhonologicalWord">PhonologicalWord</a></li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="clu.phontools.struct.SyllableProperties.coarse_stress"><code class="name">var <span class="ident">coarse_stress</span> : str</code></dt>
<dd>
<div class="desc"><p>Converts a phonological word to a sequence of S (strong) or W (weak) symbols</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def coarse_stress(self) -&gt; Text:
    &#34;&#34;&#34;Converts a phonological word to a sequence of S (strong) or W (weak) symbols&#34;&#34;&#34;
    return &#34;&#34;.join(cs.value for cs in self.coarse_stress_pattern)</code></pre>
</details>
</dd>
<dt id="clu.phontools.struct.SyllableProperties.coarse_stress_pattern"><code class="name">var <span class="ident">coarse_stress_pattern</span> : Sequence[<a title="clu.phontools.struct.CoarseStress" href="#clu.phontools.struct.CoarseStress">CoarseStress</a>]</code></dt>
<dd>
<div class="desc"><p>Maps a detailed stress sequence to a sequence of strong and weak stressed syllabled</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def coarse_stress_pattern(self) -&gt; Sequence[CoarseStress]:
    &#34;&#34;&#34;Maps a detailed stress sequence to a sequence of strong and weak stressed syllabled&#34;&#34;&#34;
    summary = []
    for stress in self.stress_pattern:
        if stress == Stress.NO_STRESS:
            summary.append(CoarseStress.WEAK)
        elif stress in {Stress.PRIMARY, Stress.SECONDARY}:
            summary.append(CoarseStress.STRONG)
    return summary</code></pre>
</details>
</dd>
<dt id="clu.phontools.struct.SyllableProperties.num_syllables"><code class="name">var <span class="ident">num_syllables</span></code></dt>
<dd>
<div class="desc"><p>A syllable contains at most one stressed element (weak or strong)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def num_syllables(self):
    &#34;&#34;&#34;A syllable contains at most one stressed element (weak or strong)&#34;&#34;&#34;
    return len(self.coarse_stress_pattern)</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="clu.phontools.struct.SyllableProperties.mask_syllables"><code class="name flex">
<span>def <span class="ident">mask_syllables</span></span>(<span>self, mask: str = 'X') ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>Converts a phonological word where each syllable is represented using the mask</p>
<p>conceptual examples:
"poo" -&gt; "X" where mask is "X"
"July" -&gt; "XX" where mask is "X"</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def mask_syllables(self, mask: Text = &#34;X&#34;) -&gt; Text:
    &#34;&#34;&#34;Converts a phonological word where each syllable is represented using the mask

    conceptual examples:
    &#34;poo&#34; -&gt; &#34;X&#34; where mask is &#34;X&#34;
    &#34;July&#34; -&gt; &#34;XX&#34; where mask is &#34;X&#34;
    &#34;&#34;&#34;
    return &#34;&#34;.join(mask for cs in self.coarse_stress_pattern)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="clu.phontools.struct.Word"><code class="flex name class">
<span>class <span class="ident">Word</span></span>
<span>(</span><span>**data: Any)</span>
</code></dt>
<dd>
<div class="desc"><p>The smallest sequence of phonemes that can be uttered in isolation with objective or practical meaning.</p>
<p>:param word: orthographic representation of this Word
:param phonological_form: the phonological form of this Word</p>
<p>Create a new model by parsing and validating input data from keyword arguments.</p>
<p>Raises ValidationError if the input data cannot be parsed to form a valid model.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Word(BaseModel, Hashable):
    r&#34;&#34;&#34;The smallest sequence of phonemes that can be uttered in isolation with objective or practical meaning.

    :param word: orthographic representation of this Word
    :param phonological_form: the phonological form of this Word
    &#34;&#34;&#34;

    word: Text
    phonological_form: PhonologicalWord

    @property
    def pf(self) -&gt; PhonologicalWord:
        &#34;&#34;&#34;Alias for phonological_form&#34;&#34;&#34;
        return self.phonological_form

    def graphemes(self) -&gt; Sequence[Text]:
        &#34;&#34;&#34;Individual characters/symbols that comprise the orthographic representation of the `clu.phontools.struct.Word`&#34;&#34;&#34;
        return &#34;&#34;.split(self.word)

    def __hash__(self) -&gt; int:
        return hash(((&#34;word&#34;, self.word), (&#34;pf&#34;, hash(self.phonological_form))))</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>pydantic.main.BaseModel</li>
<li>pydantic.utils.Representation</li>
<li><a title="clu.phontools.struct.Hashable" href="#clu.phontools.struct.Hashable">Hashable</a></li>
<li>abc.ABC</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="clu.phontools.struct.Word.phonological_form"><code class="name">var <span class="ident">phonological_form</span> : <a title="clu.phontools.struct.PhonologicalWord" href="#clu.phontools.struct.PhonologicalWord">PhonologicalWord</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="clu.phontools.struct.Word.word"><code class="name">var <span class="ident">word</span> : str</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="clu.phontools.struct.Word.pf"><code class="name">var <span class="ident">pf</span> : <a title="clu.phontools.struct.PhonologicalWord" href="#clu.phontools.struct.PhonologicalWord">PhonologicalWord</a></code></dt>
<dd>
<div class="desc"><p>Alias for phonological_form</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def pf(self) -&gt; PhonologicalWord:
    &#34;&#34;&#34;Alias for phonological_form&#34;&#34;&#34;
    return self.phonological_form</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="clu.phontools.struct.Word.graphemes"><code class="name flex">
<span>def <span class="ident">graphemes</span></span>(<span>self) ‑> Sequence[str]</span>
</code></dt>
<dd>
<div class="desc"><p>Individual characters/symbols that comprise the orthographic representation of the <code><a title="clu.phontools.struct.Word" href="#clu.phontools.struct.Word">Word</a></code></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def graphemes(self) -&gt; Sequence[Text]:
    &#34;&#34;&#34;Individual characters/symbols that comprise the orthographic representation of the `clu.phontools.struct.Word`&#34;&#34;&#34;
    return &#34;&#34;.split(self.word)</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="clu.phontools" href="index.html">clu.phontools</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="clu.phontools.struct.CoarseStress" href="#clu.phontools.struct.CoarseStress">CoarseStress</a></code></h4>
<ul class="">
<li><code><a title="clu.phontools.struct.CoarseStress.STRONG" href="#clu.phontools.struct.CoarseStress.STRONG">STRONG</a></code></li>
<li><code><a title="clu.phontools.struct.CoarseStress.WEAK" href="#clu.phontools.struct.CoarseStress.WEAK">WEAK</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="clu.phontools.struct.Hashable" href="#clu.phontools.struct.Hashable">Hashable</a></code></h4>
</li>
<li>
<h4><code><a title="clu.phontools.struct.LangUtils" href="#clu.phontools.struct.LangUtils">LangUtils</a></code></h4>
<ul class="">
<li><code><a title="clu.phontools.struct.LangUtils.all_possible_forms_for" href="#clu.phontools.struct.LangUtils.all_possible_forms_for">all_possible_forms_for</a></code></li>
<li><code><a title="clu.phontools.struct.LangUtils.all_possible_phrases_for" href="#clu.phontools.struct.LangUtils.all_possible_phrases_for">all_possible_phrases_for</a></code></li>
<li><code><a title="clu.phontools.struct.LangUtils.phonological_word_for" href="#clu.phontools.struct.LangUtils.phonological_word_for">phonological_word_for</a></code></li>
<li><code><a title="clu.phontools.struct.LangUtils.syllabify" href="#clu.phontools.struct.LangUtils.syllabify">syllabify</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="clu.phontools.struct.PhonologicalWord" href="#clu.phontools.struct.PhonologicalWord">PhonologicalWord</a></code></h4>
<ul class="">
<li><code><a title="clu.phontools.struct.PhonologicalWord.phones" href="#clu.phontools.struct.PhonologicalWord.phones">phones</a></code></li>
<li><code><a title="clu.phontools.struct.PhonologicalWord.stress_pattern" href="#clu.phontools.struct.PhonologicalWord.stress_pattern">stress_pattern</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="clu.phontools.struct.Phrase" href="#clu.phontools.struct.Phrase">Phrase</a></code></h4>
<ul class="">
<li><code><a title="clu.phontools.struct.Phrase.coarse_stress" href="#clu.phontools.struct.Phrase.coarse_stress">coarse_stress</a></code></li>
<li><code><a title="clu.phontools.struct.Phrase.coarse_stress_pattern" href="#clu.phontools.struct.Phrase.coarse_stress_pattern">coarse_stress_pattern</a></code></li>
<li><code><a title="clu.phontools.struct.Phrase.mask_syllables" href="#clu.phontools.struct.Phrase.mask_syllables">mask_syllables</a></code></li>
<li><code><a title="clu.phontools.struct.Phrase.match_coarse_stress_pattern" href="#clu.phontools.struct.Phrase.match_coarse_stress_pattern">match_coarse_stress_pattern</a></code></li>
<li><code><a title="clu.phontools.struct.Phrase.match_masked_syllables" href="#clu.phontools.struct.Phrase.match_masked_syllables">match_masked_syllables</a></code></li>
<li><code><a title="clu.phontools.struct.Phrase.phones" href="#clu.phontools.struct.Phrase.phones">phones</a></code></li>
<li><code><a title="clu.phontools.struct.Phrase.stress_pattern" href="#clu.phontools.struct.Phrase.stress_pattern">stress_pattern</a></code></li>
<li><code><a title="clu.phontools.struct.Phrase.words" href="#clu.phontools.struct.Phrase.words">words</a></code></li>
<li><code><a title="clu.phontools.struct.Phrase.words_as_phones" href="#clu.phontools.struct.Phrase.words_as_phones">words_as_phones</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="clu.phontools.struct.Stress" href="#clu.phontools.struct.Stress">Stress</a></code></h4>
<ul class="">
<li><code><a title="clu.phontools.struct.Stress.NON_VOWEL" href="#clu.phontools.struct.Stress.NON_VOWEL">NON_VOWEL</a></code></li>
<li><code><a title="clu.phontools.struct.Stress.NO_STRESS" href="#clu.phontools.struct.Stress.NO_STRESS">NO_STRESS</a></code></li>
<li><code><a title="clu.phontools.struct.Stress.PRIMARY" href="#clu.phontools.struct.Stress.PRIMARY">PRIMARY</a></code></li>
<li><code><a title="clu.phontools.struct.Stress.SECONDARY" href="#clu.phontools.struct.Stress.SECONDARY">SECONDARY</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="clu.phontools.struct.SyllableProperties" href="#clu.phontools.struct.SyllableProperties">SyllableProperties</a></code></h4>
<ul class="">
<li><code><a title="clu.phontools.struct.SyllableProperties.coarse_stress" href="#clu.phontools.struct.SyllableProperties.coarse_stress">coarse_stress</a></code></li>
<li><code><a title="clu.phontools.struct.SyllableProperties.coarse_stress_pattern" href="#clu.phontools.struct.SyllableProperties.coarse_stress_pattern">coarse_stress_pattern</a></code></li>
<li><code><a title="clu.phontools.struct.SyllableProperties.mask_syllables" href="#clu.phontools.struct.SyllableProperties.mask_syllables">mask_syllables</a></code></li>
<li><code><a title="clu.phontools.struct.SyllableProperties.num_syllables" href="#clu.phontools.struct.SyllableProperties.num_syllables">num_syllables</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="clu.phontools.struct.Word" href="#clu.phontools.struct.Word">Word</a></code></h4>
<ul class="">
<li><code><a title="clu.phontools.struct.Word.graphemes" href="#clu.phontools.struct.Word.graphemes">graphemes</a></code></li>
<li><code><a title="clu.phontools.struct.Word.pf" href="#clu.phontools.struct.Word.pf">pf</a></code></li>
<li><code><a title="clu.phontools.struct.Word.phonological_form" href="#clu.phontools.struct.Word.phonological_form">phonological_form</a></code></li>
<li><code><a title="clu.phontools.struct.Word.word" href="#clu.phontools.struct.Word.word">word</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.2</a>.</p>
</footer>
</body>
</html>